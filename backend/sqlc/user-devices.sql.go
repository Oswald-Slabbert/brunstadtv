// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: user-devices.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getDevicesForProfiles = `-- name: getDevicesForProfiles :many
SELECT token, profile_id, updated_at, name FROM users.devices WHERE profile_id = ANY($1::uuid[])
`

func (q *Queries) getDevicesForProfiles(ctx context.Context, dollar_1 []uuid.UUID) ([]UsersDevice, error) {
	rows, err := q.db.QueryContext(ctx, getDevicesForProfiles, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersDevice
	for rows.Next() {
		var i UsersDevice
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDeviceToken = `-- name: setDeviceToken :exec
INSERT INTO users.devices (token, profile_id, updated_at, name)
VALUES ($1::varchar, $2::uuid, $3::timestamp, $4::varchar)
ON CONFLICT (token, profile_id) DO UPDATE SET updated_at = EXCLUDED.updated_at, name = EXCLUDED.name
`

type setDeviceTokenParams struct {
	Column1 string    `db:"column_1" json:"column1"`
	Column2 uuid.UUID `db:"column_2" json:"column2"`
	Column3 time.Time `db:"column_3" json:"column3"`
	Column4 string    `db:"column_4" json:"column4"`
}

func (q *Queries) setDeviceToken(ctx context.Context, arg setDeviceTokenParams) error {
	_, err := q.db.ExecContext(ctx, setDeviceToken,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	return err
}
