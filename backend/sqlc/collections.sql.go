// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: collections.sql

package sqlc

import (
	"context"

	"github.com/lib/pq"
)

const getCollectionEntriesForCollections = `-- name: getCollectionEntriesForCollections :many
SELECT id, collections_id, item, collection, sort
FROM collections_entries ci
WHERE ci.collections_id = ANY ($1::int[])
`

func (q *Queries) getCollectionEntriesForCollections(ctx context.Context, dollar_1 []int32) ([]CollectionsEntry, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionEntriesForCollections, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionsEntry
	for rows.Next() {
		var i CollectionsEntry
		if err := rows.Scan(
			&i.ID,
			&i.CollectionsID,
			&i.Item,
			&i.Collection,
			&i.Sort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionEntriesForCollectionsWithRoles = `-- name: getCollectionEntriesForCollectionsWithRoles :many
SELECT ce.id, ce.collections_id, ce.item, ce.collection, ce.sort
FROM collections_entries ce
         LEFT JOIN episode_roles er ON ce.collection = 'episodes' AND er.id::varchar = ce.item
         LEFT JOIN episode_availability ea ON ce.collection = 'episodes' AND ea.id::varchar = ce.item
         LEFT JOIN season_roles sr ON ce.collection = 'seasons' AND sr.id::varchar = ce.item
         LEFT JOIN season_availability sa ON ce.collection = 'seasons' AND sa.id::varchar = ce.item
         LEFT JOIN show_roles shr ON ce.collection = 'shows' AND shr.id::varchar = ce.item
         LEFT JOIN show_availability sha ON ce.collection = 'shows' AND sha.id::varchar = ce.item
WHERE ce.collections_id = ANY ($1::int[])
    AND(ce.collection != 'episodes' OR (
        ea.published
        AND ea.available_to > now()
        AND er.roles && $2::varchar[] AND ea.available_from < now()
    ))
  AND ce.collection != 'seasons'
  AND (ce.collection != 'shows' OR (
        sha.published
        AND sha.available_to > now()
        AND shr.roles && $2::varchar[] AND sha.available_from < now()
    ))
ORDER BY ce.sort
`

type getCollectionEntriesForCollectionsWithRolesParams struct {
	Column1 []int32  `db:"column_1" json:"column1"`
	Column2 []string `db:"column_2" json:"column2"`
}

func (q *Queries) getCollectionEntriesForCollectionsWithRoles(ctx context.Context, arg getCollectionEntriesForCollectionsWithRolesParams) ([]CollectionsEntry, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionEntriesForCollectionsWithRoles, pq.Array(arg.Column1), pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionsEntry
	for rows.Next() {
		var i CollectionsEntry
		if err := rows.Scan(
			&i.ID,
			&i.CollectionsID,
			&i.Item,
			&i.Collection,
			&i.Sort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollections = `-- name: getCollections :many
SELECT date_created, date_updated, id, sort, user_created, user_updated, filter_type, name, query_filter, advanced_type
FROM collections c
WHERE c.id = ANY ($1::int[])
`

func (q *Queries) getCollections(ctx context.Context, dollar_1 []int32) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, getCollections, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.DateCreated,
			&i.DateUpdated,
			&i.ID,
			&i.Sort,
			&i.UserCreated,
			&i.UserUpdated,
			&i.FilterType,
			&i.Name,
			&i.QueryFilter,
			&i.AdvancedType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollections = `-- name: listCollections :many
SELECT date_created, date_updated, id, sort, user_created, user_updated, filter_type, name, query_filter, advanced_type
FROM collections
`

func (q *Queries) listCollections(ctx context.Context) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.DateCreated,
			&i.DateUpdated,
			&i.ID,
			&i.Sort,
			&i.UserCreated,
			&i.UserUpdated,
			&i.FilterType,
			&i.Name,
			&i.QueryFilter,
			&i.AdvancedType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
